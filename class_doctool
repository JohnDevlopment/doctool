#!/usr/bin/perl

use strict;
use warnings;
use v5.10;

# Doctool Modules
use FindBin;
use lib "$FindBin::Bin/lib";

use Doctool::Getline;
use Doctool::Util qw(append echo str push_back strextract);
use String::Util qw(ltrim rtrim hascontent contains);
use Readonly;

use Digest::MD5 qw(md5_hex);

my %g_sec_tag_keys = qw(desc description note note);
my %g_sections;
Readonly::Scalar my $g_sec_tags => qr/desc|note/;

use constant POD_TYPES => qw(
    float int void Variant String Dictionary Array
    PoolRealArray PoolIntArray PoolStringArray
    PoolVector2Array PoolVector3Array PoolColorArray
);

use constant COMPLEX_TYPES => qw(
    Vector2
    Vector3
    Rect2
    Transform2D
    Transform
    Plane
    Quat
    AABB
    Basis
    Color
    NodePath
    RID
    Object
);

use constant {
    GET_FIELD_ARG_NAME => 0,
    GET_FIELD_ARG_TYPE => 1,
    GET_FIELD_ARG_DEFAULT => 2
};

# Usage: _delete_block_attr text attr value
sub _delete_block_attr ($$$) {
    my ($text,$attr,$value) = @_;
    my $block = qr/section|article|div|table|header|tr|td|tbody/;
    $text =~ s{
        (
            ^              # Spaces from the start
            [ \t]*         # leading to the block
            <($block)      # $2 = block
            \s+            # One or more spaces
            $attr="$value" # Specific attribute
            (?:.|\n)*?     # Any number lines
            </\2>          # Matching end tag
            [ \t]*         # Trailing spaces
            \n?            # Newline
        )
    }{
        my $key = md5_hex($1);
        "<!-- " . $key . " -->\n";
    }emx;

    return $text;
}

# Usage: delete_block string, class
sub delete_block_class ($$) {return _delete_block_attr($_[0], 'class', $_[1]);}

# Usage: delete_block string, id
sub delete_block_id ($$) {return _delete_block_attr($_[0], 'id', $_[1]);}

# Main subroutine
sub Doctool {
    my $text = shift or die "Needs a string argument";

    my %parse_subs = (
        export => \&_ParseProperty,
        class => \&_ParseClass,
        signal => \&_ParseSignal,
        method => \&_ParseMethod
    );

    # Clear global hash
    %g_sections = (
        signals => [],
        methods => [],
        properties => [],
        header => []
    );

    # Standardize line endings:
    $text =~ s{\r\n}{\n}g; 	# DOS to Unix
    $text =~ s{\r}{\n}g; 	# Mac to Unix

    # Require that the very first line be a comment with two "#" and text
    die 'No documentation found for this class' unless ($text =~ /^##\s*.+/);

    while ($text =~ /^(?=##\s*)/gm) {
        my $index = pos($text);
        my $doc = _DetectDocType($text, $index);

        my $key = $doc->{'type'};
        if (exists $parse_subs{$key}) {
            &{$parse_subs{$key}}($doc->{'text'});
        }
    }

    return _BuildHTML();
}

sub _BuildHTML {
    my $html = Doctool::Util::readfile("$FindBin::Bin/template.html");

    # Parse header section
    my %header = %{ $g_sections{'header'} };

    {
        my $extends = sprintf('<p>Inherits from: %s</p>', $header{'extends'});
        $html =~ s{
            \n
            ([ \t]*)
            (?=.*\[BRIEF\])
        }{
            "\n$1" . $extends . "\n$1";
        }ex;
    }

    $html =~ s/\[CLASSNAME\]/$header{'class'}/g;
    $html =~ s/\[BRIEF\]/$header{'brief'}/;

    if ( $header{'description'}->$#* >= 1 ) {
        # Description
        my $text = '';
        for my $i (0 .. $header{'description'}->$#*) {
            $text = $text . '<p>' . $header{'description'}[$i] . '</p>';
        }

        if (exists $header{'note'}) {
            my $buf = '';
            for my $i (0 .. $header{'note'}->$#*) {
                $buf = $buf . '<p>' . $header{'note'}[$i] . '</p>';
            }
            $text = $text . sprintf(q^<div class="note">%s</div>^, $buf);
        }
        $html =~ s/\[DESC\]/$text/;
    } else {
        $html = delete_block_id($html, 'description');
    }

    # Properties section
    if (! exists $g_sections{'properties'}) {
        $html = delete_block_id($html, 'properties');
    } else {
        _HTMLProperty(\$html);
    }

    # Methods section
    if (! exists $g_sections{'methods'}) {
        $html = delete_block_id($html, 'methods');
    } else {
        _HTMLMethod(\$html);
    }

    # Signals section
    if (! exists $g_sections{'signals'}) {
        $html = delete_block_id($html, 'signals');
    } else {
        _HTMLSignal(\$html);
    }

    _ParseFormatTags(\$html);
    _FormatTypeNames(\$html);

    $html =~ s/<!--.*?-->//g;
    $html = String::Util::crunchlines($html);

    return $html;
}

sub _HTMLMethod {
    my $r_html = shift;
    my $r_methods = $g_sections{'methods'};

    Readonly my %c_abbr_titles => (
        virtual => 'This method should typically be overridden by the use to have any effect.',
        const => 'This method does not modify any of the instance variables.'
    );

    Readonly my $c_method_desc_template => Doctool::Util::readfile("$FindBin::Bin/c/methoddesc.html");

    my $method_section = '';
    foreach my $method (@$r_methods) {
        my $method_html = $c_method_desc_template;

        $method_html =~ s/\[METHODNAME\]/$method->get('name')/e;

        {
            my $text = $method->as_text();

            # Enclose the method name in b tags
            my @idx = ( index($text, $method->get('name')), length($method->get('name')) );
            substr($text, $idx[0], $idx[1], '<b>' . $method->get('name') . '</b>');

            # Enclose the words "virtual" and "const" in abbr tags
            $text =~ s{\b(virtual|const)\b}{
                sprintf(q^<abbr title="%s">%s</abbr>^, $c_abbr_titles{$1}, $1);
            }eg;

            $method_html =~ s/\[METHODSIG\]/$text/;
        }

        my $graffs = '';

        {
            my $brief = $method->get('brief');
            if ( hascontent($brief) ) {
                append($graffs, '<p class="brief">' . $brief . '</p>');
            }

            my $r_method_descs = $method->get('description');
            if ( ref($r_method_descs) eq 'ARRAY' ) {
                for my $i (0 .. $r_method_descs->$#*) {
                    append($graffs, '<p>' . $r_method_descs->[$i] . '</p>');
                }
            }
            $method_html =~ s/\[METHODDESC\]/$graffs/;
        }

        append($method_section, $method_html);
    }

    $$r_html =~ s/\[METHODS\]/$method_section/;

    delete $g_sections{'methods'};
}

sub _HTMLSignal {
    my $r_html = shift;
    my $r_signals = $g_sections{'signals'};
    my $signal_section = '';

    Readonly my $c_signalref_html => Doctool::Util::readfile("$FindBin::Bin/c/signalref.html");

    foreach my $signal (@$r_signals) {
        my $signalref_html = $c_signalref_html;

        $signalref_html =~ s/\[SIGNALSIG\]/$signal->as_text()/e;
        $signalref_html =~ s/\[SIGNALNAME\]/$signal->get('name')/eg;
        $signalref_html =~ s/\[SIGNALBRIEF\]/$signal->get('brief')/eg;

        # Add paragraphs to the signal section
        my $text = '';
        my $r_signaldescs = $signal->get('description');
        if ( ref($r_signaldescs) eq 'ARRAY' ) {
            for my $i (0 .. $r_signaldescs->$#*) {
                append($text, '<p>' . $r_signaldescs->[$i] . '</p>');
            }
        }
        $signalref_html =~ s/\[SIGNALDESC\]/$text/;

        append($signal_section, $signalref_html . '<hr class="faint-line">');
    }

    {
        my $temp = rindex($signal_section, '<hr class="faint-line">');
        if ($temp >= 0) {
            substr($signal_section, $temp, length('<hr class="faint-line">')) = '';
        }
    }

    $$r_html =~ s/\[SIGNALS\]/$signal_section/;
}

sub _HTMLProperty {
    my $r_html = shift;
    my $table = "<table class=\"bicolor\"><tr><th>Type</th><th>Name</th><th>Default</th></tr>";
    my $properties = $g_sections{'properties'};
    my $propdescs = '';

    Readonly my $c_propdesc_html => Doctool::Util::readfile("$FindBin::Bin/c/propdesc.html");

    my $r_fixquotes = sub {
        no warnings;
        my $text = shift;
        my $type = shift;
        if ($type eq 'String') {
            my $quote = chr(0x22);
            return $text if ($text =~ /^\x22.*\x22/); # return if properly quoted
            return $text =~ s/\x27/$quote/rg; # replace single quotes with double quotes
        }
        return $text;
    };

    foreach my $prop (@$properties) {
        my $text = sprintf('<tr><td>%s</td><td>%s</td><td>%s</td></tr>', $prop->get('type'), $prop->get('name'), $prop->get('default'));
        append($table, $text . "\n");

        my $propdesc = $c_propdesc_html;

        $propdesc =~ s/\[PROPNAME\]/$prop->get('name')/eg;
        $propdesc =~ s/\[PROPSIG\]/$prop->get('type') . ' ' . $prop->get('name')/e;

        my $deleted = 0;

        # Default value
        if ($prop->get('default') ne '') {
            my $temp = &$r_fixquotes($prop->get('default'), $prop->get('type'));
            $propdesc =~ s/\[PROPDEFAULT\]/$temp/;
        } else {
            $propdesc = delete_block_id($propdesc, $prop->get('name') . "_default");
            ++$deleted;
        }

        # Property setter function
        if ($prop->get('setter') ne '') {
            $propdesc =~ s/\[PROPSETTER\]/$prop->get('setter')/e;
        } else {
            $propdesc = delete_block_id($propdesc, $prop->get('name') . "_setter");
            ++$deleted;
        }

        # Property getter function
        if ($prop->get('getter') ne '') {
            $propdesc =~ s/\[PROPGETTER\]/$prop->get('getter')/e;
        } else {
            $propdesc = delete_block_id($propdesc, $prop->get('name') . "_getter");
            ++$deleted;
        }

        # If all table elements are deleted
        if ($deleted >= 3) {
            $propdesc = delete_block_class($propdesc, "bicolor_light");
        }

        # Property description
        {
            my $r_array = $prop->get('description');
            if (ref($r_array) eq 'ARRAY') {
                $text = '';
                foreach (@$r_array) {
                    append($text, '<p>' . $_ . '</p>');
                }
                $propdesc =~ s/\[PROPDESC\]/$text/e;
            } else {
                $propdesc =~ s/\[PROPDESC\]//;
            }
        }

        append($propdescs, $propdesc);
    }
    append($table, "</table>");

    $$r_html =~ s{\[PROPERTIES\]}{$table . "\n<br>\n" . $propdescs}e;
}

sub _FormatTypeNames {
    my $r_html = shift;

    my $pattern;
    {
        my $temp = join('|', POD_TYPES);
        $pattern = qr/$temp/;
    }

    $$r_html =~ s{\b($pattern)\b}{
        sprintf(q^<span class="podtype">%s</span>^, $1);
    }eg;

    {
        my $temp = join('|', COMPLEX_TYPES);
        $pattern = qr/$temp/;
    }

    $$r_html =~ s{\b($pattern)}{
        sprintf(q^<span class="complextype">%s</span>^, $1);
    }eg;
}

sub _ParseFormatTags {
    my $r_html = shift;
    my %tags = (
        code => '<code>%s</code>',
        b => '<b>%s</b>',
        i => '<i>%s</i>',
        a => '<i class="argument">%s</i>',
        function => '<code class="function">%s</code>',
        class => '<code class="class">%s</code>'
    );

    $$r_html =~ s/\@br/<br>/g;

    my $pattern;
    {
        my $temp = join('|', keys %tags);
        $pattern = qr/$temp/;
    }

    $$r_html =~ s{
        (?:
            \@($pattern)
            \s+
            (\w+)
        )
    }{
        sprintf($tags{$1}, $2);
    }egx;

    $$r_html =~ s{
        (?:
            \@($pattern)
            \{
            (\N+)
            \}
        )
    }{
        sprintf($tags{$1}, $2);
    }egx;
}

# Returns what type of documentation we're dealing with, also isolates the chunk for us
# Params
#    text to sift through
#    index to start the search from
# Return value
#    A reference to a hash with two fields
#      * $hash{'text'} = a string with the documentation and the entity being documented
#      * $hash{'type'} = string denoting the type of documentation
sub _DetectDocType {
    my $text = shift;
    my $index = shift;
    my $doc_text = '';
    my $doc_type = 'unknown';
    my $is_func = 0;

    # Continue until you reach a non-comment line
    my $line;
    do {
        use String::Util qw(startswith endswith);
        $line = getline($text, $index);
        if (! $is_func) {
            append($doc_text, $line . "\n");
        } else {
            if (startswith($line, "\t")) {
                $line = '';
            }
            append($doc_text, $line . "\n");
        }

        if (startswith($line, 'func')) {
            $is_func = 1;
        }
    } while ( hascontent($line) );

    # In the case of a one-line function, hide the code in the body
    # func example() -> void: pass
    #                         ^^^^
    #                         Removes this
    if ($is_func) {
        $doc_text = rtrim($doc_text);
        $doc_text =~ s/(func.*:).*$/$1/;
    }

    $doc_text = ltrim($doc_text); # Trim leading whitespace

    no warnings;
    given ($doc_text) {
        when (/^(?:export)?.*[ \t]*var\b.*/m) {
            $doc_type = 'export';
        }
        when (/^(class_name|extends).*/m) {
            $doc_type = 'class';

            if ($1 eq 'class_name') {
                if ( ! contains($doc_text, 'extends') ) {
                    $index = index($text, 'extends');
                    append($doc_text, getline($text, $index));
                }
            } else {
                if ( ! contains($doc_text, 'class_name') ) {
                    $index = index($text, 'class_name');
                    append($doc_text, getline($text, $index));
                }
            }
        }
        when (/^signal[ \t]+\w+/m) {
            $doc_type = 'signal';
        }
        when (/^func[ \t]+\w+[ \t]*\((.|\n)*\).*:/m) {
            $doc_type = 'method';
        }
        default {1;}
    }

    $doc_text =~ s/\n\n/\n/m;

    return { 'text' => $doc_text, 'type' => rtrim($doc_type) };
}

# Usage: _GetParagraphs $text \$index
# Returns a reference to an array of paragraph strings
# Entry condition: $index is set to the index right after the tag name in $text
sub _GetParagraphs {
    my $text = shift;
    my $r_index = shift; # reference

    my $index = $$r_index;
    my $graff = getline($text, $index);

    my $line;
    my @pars = ();

    do {
        $line = getline($text, $index);

        # Look for text on each line
        if ($line =~ /^#\s*(.+)/) {
            my $add_to_graff = $1;

            # New paragraph, and the first thing we see is a section tag
            # FIXME: this might present an issue for the cases where $g_sec_tags is found directly one line below a paragraph (no empty line above it)
            if ($graff eq '' && $line =~ /^#\s*\@$g_sec_tags/) {
                $line = '';
                prevline($text, $index);
            } else {
                $graff = $graff . " $add_to_graff";
            }
        } else {
            # Ending the paragraph and appending it to the array
            if ($graff ne '') {
                $graff =~ s{\@$g_sec_tags}{}g; # Remove stray section tags
                $graff = ltrim($graff);
                $graff =~ s{\s\s+}{ }g; # Turn duplicate spaces into just one
                push_back(@pars, $graff);
                $graff = '';
            }
        }
    } while (index($line, '#') == 0);

    $$r_index = $index;

    return \@pars;
}

# _ParseMethod string \%hash_with_subs
sub _ParseMethod {
    use Doctool::Method;
    use Doctool::Arg;
    use String::Util 'collapse';

    my $text = shift;
    my $method = Doctool::Method->new();

    # $1 = name
    # $2 = args
    # $3 = return type
    unless (
        $text =~ m{
            ^          #
            func       # Starts with the word "func" followed by spaces.
            [ \t]+     #
            (\w+)      # Function name = $1
            [ \t]*     #
            \(         #
            (.*)       # Inside paranthesis are the parameters (can be multiline)
            \)         # which, if defined, are captured in $2.
            [ \t]*     #
            (?:        # Optional return type
                \s*    #
                ->     # Needs '->'
                \s*    #
                (\w*)  # And the type name, captured in $3.
            )?
        }mxs
    ) {
        die "Malformed function: $text";
    }

    $method->set('name', $1); # Method name

    # Argument list
    if (defined $2) {
        my @arglist = split(/\,[ \t\n]*/, $2);
        foreach my $arg (@arglist) {
            my $obj = Doctool::Arg->new();

            {
                # $1 = name
                my $match = strextract(qr/(\w+)\:?/, $arg, 1);
                die "Missing argument name: \"$arg\"" if (! $match);
                $obj->set('name', $match);

                # type
                $match = strextract(qr/\:[ \t]*(\w+)/, $arg, 1);
                $obj->set('type', ($match) ? $match : 'Variant');

                # default
                $match = strextract(qr/\=[ \t]*(.+)/, $arg, 1);
                $obj->set('default', $match);
            }

            $method->add_arg($obj);
        }
    }

    {
        # Method return type
        my $rettype = defined($3) ? collapse($3) : 'Variant';
        $method->set('returntype', $rettype);

        # Description
        my $brief = strextract(qr/^##[ \t]*(.+)/, $text, 1);
        if ( hascontent($brief) ) {
            $method->set('brief', $brief);
        }

        my $i = index($text, '@desc');
        if ($i > 0) {
            $i += length('@desc');
            $method->set('description', _GetParagraphs($text, \$i));
        }
    }

    $method->set($1, 1) while ($text =~ /#[ \t]*\@(virtual|const)$/mg);

    push($g_sections{'methods'}->@*, $method);
}

# _ParseSignal string
# Fields: brief (string), desc(string, optional), name(string)
sub _ParseSignal {
    use Doctool::Signal;
    use Doctool::Arg;

    my $text = shift;
    my $signal = Doctool::Signal->new();

    # Name of the signal
    $text =~ /^signal\s+(\w+)/m;
    $signal->set('name', $1);

    # Signal parameters
    while ( $text =~ /^#\s*\@arg\s*(\w+)\s+(\w+)\s+(.+)/gm ) {
        my $arg = Doctool::Arg->new();
        $arg->set('type', $1);
        $arg->set('name', $2);
        $arg->set('description', $3);
        $signal->add_arg($arg);
    }

    # Brief description
    if ($text =~ /^##\s*(.+)/) {
        $signal->set('brief', $1);
    }

    # Full description
    my $i = index($text, '@desc');
    if ($i > 0) {
        $i += length('@desc');
        $signal->set('description', _GetParagraphs($text, \$i));
    }

    push($g_sections{'signals'}->@*, $signal);
}

# _ParseClass string
# Fields: brief (string), class (string), desc (string, optional), extends(string)
sub _ParseClass {
    my $text = shift;
    my %header;
    my $line;
    my $index = 0;

    # Look for the name of the class
    $text =~ /class_name\s+(\w+)/;
    $header{'class'} = $1;

    # Get the brief description first.
    $line = getline($text, $index);
    $header{'brief'} = ($text =~ /^##\s*(.+)/) ? $1 : 'No description available';

    # Look for tags in the comments
    do {
        $line = getline($text, $index);

        # If a section-tag is found:
        if ($line =~ /^#\s*\@($g_sec_tags)/) {
            my $tag = $1; # e.g., 'desc'
            my $key = $g_sec_tag_keys{$tag}; # e.g., 'description'

            # Move index in front of tag
            # To explain the math here:
            # $index is currently the index to the NEXT line, so we subtract the length
            # of THIS line, and subtract one, to bring it back to the start of the current line.
            # Then we add the index of the tag (e.g., "@desc") to it, then add its length,
            # to bring the index in front of the tag.
            # The result should be that $index is at the index after  the tag.
            my $i = index($line, '@' . $1);
            $index = ($index - length($line) - 1) + $i + length('@' . $1);

            $header{$key} = _GetParagraphs($text, \$index);
        }
    } while (index($line, '#') == 0);

    die q/Syntax error: no "extends" found in input/ unless ($text =~ /^extends[ \t]+(\w+)/m);
    $header{'extends'} = $1;

    $g_sections{'header'} = \%header;
}

# _ParseProperty string
# Note: $g_section{'properties'} is a list of Doctool::Property objects.
#       The attributes are: brief, name, default, type, description (ARRAY)
sub _ParseProperty {
    use Doctool::Property;
    my $text = shift;
    my $prop = Doctool::Property->new();
    my $index = 0;
    my $line = '';

    # Get the brief description first.
    $line = getline($text, $index);
    $prop->set( 'brief', ($text =~ /^##\s*(.+)/) ? $1 : 'No description available' );

    # Name
    die "REGEX failed" unless ($text =~ /^(?:export.*)?\s*var\s+(\w+)/m);
    $prop->set('name', $1);

    # Property type
    die str("Property ", $prop->get('name'), " needs a type") unless ($text =~ /^#\s*\@type\s+(\w+)/m);
    $prop->set('type', $1);

    # Default
    if ($text =~ /\=\s*(\N+)/) {
        $prop->set('default', $1);
    }

    # Getter/setter function
    while ($text =~ /\@([sg]etter)[ \t]+(\w+\(.*\))/g) {
        my $tag = $1;
        if ($tag eq 'setter') {
            $prop->set('setter', $2);
        } else {
            $prop->set('getter', $2);
        }
    }

    do {
        $line = getline($text, $index);

        # Found a section tag
        if ($line =~ /^#\s*\@($g_sec_tags)/) {
            my $tag = $1; # e.g., 'desc'
            my $key = $g_sec_tag_keys{$tag}; # e.g., 'description'

            # Move index in front of tag
            # To explain the math here:
            # $index is currently the index to the NEXT line, so we subtract the length
            # of THIS line, and subtract one, to bring it back to the start of the current line.
            # Then we add the index of the tag (e.g., "@desc") to it, then add its length,
            # to bring the index in front of the tag.
            # The result should be that $index is at the index after  the tag.
            my $i = index($line, '@' . $1);
            $index = ($index - length($line) - 1) + $i + length('@' . $1);

            $prop->set('description', _GetParagraphs($text, \$index));
        }
    } while (index($line, '#') == 0);

    push($g_sections{'properties'}->@*, $prop);
}

# Read file given by argument
if (defined($ARGV[0])) {
    my $text;
    local $/;
    defined($text = <>) or exit 1;
    print Doctool($text);
}

1;
