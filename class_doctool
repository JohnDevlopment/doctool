#!/usr/bin/perl

use strict;
use warnings;
use 5.022_000;

# Doctool Modules
use FindBin;
use lib "$FindBin::Bin/lib";

use Doctool::Getline;
use Doctool::Util qw(append echo printerr str strextract);

use String::Util qw(startswith endswith ltrim rtrim hascontent contains);
#use autouse 'String::Util' => qw(startswith endswith ltrim rtrim hascontent contains);

use Readonly;
use Digest::MD5 qw(md5_hex);

use subs qw(Doctool ParseEntity);

my %g_sections;

Readonly my $g_brief_regex => qr/##[ \t]*(.+)/;

Readonly my %g_parse_subs => (
    export => \&_ParseProperty,
    class => \&_ParseClass,
    signal => \&_ParseSignal,
    method => \&_ParseMethod,
    constant => \&_ParseConstant,
    enum => \&_ParseEnum
);

my %g_html_templates = ();

use constant POD_TYPES => qw(
    float int void bool Variant String Dictionary Array
    PoolRealArray PoolIntArray PoolStringArray
    PoolVector2Array PoolVector3Array PoolColorArray
);

use constant COMPLEX_TYPES => qw(
    Vector2
    Vector3
    Rect2
    Transform2D
    Transform
    Plane
    Quat
    AABB
    Basis
    Color
    NodePath
    RID
    Object
);

# Read file given by argument
if (defined($ARGV[0])) {
    my $text;
    local $/;
    defined($text = <>) or exit 1;
    print Doctool($text);
} else {
    echo "No file name given";
}

# Main subroutine
sub Doctool {
    my $text = shift or die "Needs a string argument";

    # Clear global hash
    %g_sections = (
        header => {},
        methods => [],
        signals => [],
        constants => [],
        properties => [],
        enums => []
    );

    # Standardize line endings:
    $text =~ s{\r\n}{\n}g; 	# DOS to Unix
    $text =~ s{\r}{\n}g; 	# Mac to Unix

    # Require that the very first line be a comment with two "#" and text
    die 'No documentation found for this class' unless ($text =~ /^##\s*.+/);

    while ($text =~ /^(?=##\s*)/gm) {
        my $index = pos($text);
        my $doc = _DetectDocType($text, $index);

        ParseEntity($doc->{'text'}, $doc->{'type'});
    }

    return _BuildHTML();
}

# HTML methods

# Usage: _delete_block_attr text attr value
sub _delete_block_attr ($$$) {
    my ($text,$attr,$value) = @_;
    my $block = qr/section|article|div|table|header|tr|td|tbody/;
    $text =~ s{
        (
            ^              # Spaces from the start
            [ \t]*         # leading to the block
            <($block)      # $2 = block
            \s+            # One or more spaces
            $attr="$value" # Specific attribute
            (?:.|\n)*?     # Any number lines
            </\2>          # Matching end tag
            [ \t]*         # Trailing spaces
            \n?            # Newline
        )
    }{
        my $key = md5_hex($1);
        "<!-- " . $key . " -->\n";
    }emx;

    return $text;
}

sub _LoadTemplateOnce ($$) {
    use Doctool::Util 'readfile';

    my $field = shift;
    my $file = str("$FindBin::Bin/", shift);

    if (! exists $g_html_templates{$field}) {
        #echo "_LoadTemplateOnce: load $file";
        $g_html_templates{$field} = readfile($file);
    }

    return $g_html_templates{$field};
}

# Usage: delete_block string, class
sub delete_block_class ($$) {return _delete_block_attr($_[0], 'class', $_[1]);}

# Usage: delete_block string, id
sub delete_block_id ($$) {return _delete_block_attr($_[0], 'id', $_[1]);}

sub _BuildHTML {
    _LoadTemplateOnce 'template', 'template.html';

    my $html = $g_html_templates{'template'};

    my %header = %{ $g_sections{'header'} };

    # Base class
    my $extends = sprintf('<p>Inherits from: %s</p>', $header{'extends'});
    $html =~ s{
        \n
        ([ \t]*)
        (?=.*\[BRIEF\])
    }{
        "\n$1" . $extends . "\n$1";
    }ex;

    $html =~ s/\[CLASSNAME\]/$header{'class'}/g;
    $html =~ s/\[BRIEF\]/$header{'brief'}/;

    # Description
    if (exists $header{'description'} && $header{'description'}->$#* >= 1 ) {
        my $text = '';
        for my $i (0 .. $header{'description'}->$#*) {
            $text = $text . '<p>' . $header{'description'}[$i] . '</p>';
        }
        $html =~ s/\[DESC\]/$text/;
    } else {
        $html = delete_block_id($html, 'description');
    }

    # Properties section
    if ($g_sections{'properties'}->$#* < 0) {
        $html = delete_block_id($html, 'properties');
    } else {
        _HTMLProperty(\$html);
    }

    # Methods section
    if ($g_sections{'methods'}->$#* < 0) {
        $html = delete_block_id($html, 'methods');
    } else {
        _HTMLMethod(\$html);
    }

    # Signals section
    if ( $g_sections{'signals'}->$#* < 0 ) {
        $html = delete_block_id($html, 'signals');
    } else {
        _HTMLSignal(\$html);
    }

    # Enums section
    if ( $g_sections{'enums'}->$#* < 0 ) {
        $html = delete_block_id($html, 'enumerations');
    } else {
        _HTMLEnum(\$html);
    }

    # Constants
    if ($g_sections{'constants'}->$#* < 0) {
        $html = delete_block_id($html, 'constants');
    } else {
        my $text = '<ul>';
        my $constants = $g_sections{'constants'};
        foreach my $const (@$constants) {
            my $const_ref = _LoadTemplateOnce('const', 'c/constref.html');
            $const_ref =~ s{\[CONSTNAME\]}{
                sprintf(q^<b>%s</b> = %s^, $const->{'name'}, $const->{'value'})
            }eg;
            $const_ref =~ s/\[CONSTBRIEF\]/$const->{'brief'}/e;
            append($text, $const_ref);
        }
        append($text, '</ul>');
        $html =~ s/\[CONSTANTS\]/$text/;
    }

    _ParseFormatTags(\$html);
    _FormatTypeNames(\$html);

    $html =~ s/<!--.*?-->//g;
    $html = String::Util::crunchlines($html);

    return $html;
}

sub _HTMLEnum {
    my $r_html = shift;
    my $r_enums = $g_sections{'enums'};

    my $enum_section = '';

    foreach my $enum (@$r_enums) {
        my $enumref_html = _LoadTemplateOnce('enum', 'c/enumref.html');
        $enumref_html =~ s/\[ENUMNAME\]/$enum->get('name')/e;

        # \n<!--[ \t]*(<li>.+</li>)
        my $enumconst_html = strextract(qr^\n<!--[ \t]*(<li>.+</li>)^, $enumref_html, 1);

        my $enum_constants = '';
        foreach ( @{ $enum->get('members') } ) {
            #echo sprintf('%s = %s -- %s', $_->{'name'}, $_->{'value'}, $_->{'brief'});
            append $enum_constants, sprintf($enumconst_html, $_->{'name'}, $_->{'value'}, $_->{'brief'});
        }

        $enumref_html =~ s/\[ENUMCONSTLIST\]/$enum_constants/;

        append $enum_section, $enumref_html,
    }

    $$r_html =~ s/\[ENUMERATIONS\]/$enum_section/;
}

sub _HTMLMethod {
    my $r_html = shift;
    my $r_methods = $g_sections{'methods'};

    Readonly my %c_abbr_titles => (
        virtual => 'This method should typically be overridden by the use to have any effect.',
        const => 'This method does not modify any of the instance variables.'
    );

    my $method_section = '';
    foreach my $method (@$r_methods) {
        my $method_html = _LoadTemplateOnce('method', 'c/methoddesc.html');

        $method_html =~ s/\[METHODNAME\]/$method->get('name')/e;

        {
            my $text = $method->as_text();

            # Enclose the method name in b tags
            my @idx = ( index($text, $method->get('name')), length($method->get('name')) );
            substr($text, $idx[0], $idx[1], '<b>' . $method->get('name') . '</b>');

            # Enclose the words "virtual" and "const" in abbr tags
            $text =~ s{\b(virtual|const)\b}{
                sprintf(q^<abbr title="%s">%s</abbr>^, $c_abbr_titles{$1}, $1);
            }eg;

            $method_html =~ s/\[METHODSIG\]/$text/;
        }

        my $graffs = '';

        {
            my $brief = $method->get('brief');
            if ( hascontent($brief) ) {
                append($graffs, '<p class="brief">' . $brief . '</p>');
            }

            my $r_method_descs = $method->get('description');
            if ( ref($r_method_descs) eq 'ARRAY' ) {
                for my $i (0 .. $r_method_descs->$#*) {
                    append($graffs, '<p>' . $r_method_descs->[$i] . '</p>');
                }
            }
            $method_html =~ s/\[METHODDESC\]/$graffs/;
        }

        append($method_section, $method_html);
    }

    $$r_html =~ s/\[METHODS\]/$method_section/;

    delete $g_sections{'methods'};
}

sub _HTMLSignal {
    my $r_html = shift;
    my $r_signals = $g_sections{'signals'};
    my $signal_section = '';

    foreach my $signal (@$r_signals) {
        my $signalref_html = _LoadTemplateOnce('signal', 'c/signalref.html');

        $signalref_html =~ s/\[SIGNALSIG\]/$signal->as_text()/e;
        $signalref_html =~ s/\[SIGNALNAME\]/$signal->get('name')/eg;
        $signalref_html =~ s/\[SIGNALBRIEF\]/$signal->get('brief')/eg;

        # Add paragraphs to the signal section
        my $text = '';
        my $r_signaldescs = $signal->get('description');
        if ( ref($r_signaldescs) eq 'ARRAY' ) {
            for my $i (0 .. $r_signaldescs->$#*) {
                append($text, '<p>' . $r_signaldescs->[$i] . '</p>');
            }
        }
        $signalref_html =~ s/\[SIGNALDESC\]/$text/;

        append($signal_section, $signalref_html . '<hr class="faint-line">');
    }

    {
        my $temp = rindex($signal_section, '<hr class="faint-line">');
        if ($temp >= 0) {
            substr($signal_section, $temp, length('<hr class="faint-line">')) = '';
        }
    }

    delete $g_sections{'signals'};

    $$r_html =~ s/\[SIGNALS\]/$signal_section/;
}

sub _HTMLProperty {
    my $r_html = shift;
    my $table = "<table class=\"bicolor\"><tr><th>Type</th><th>Name</th><th>Default</th></tr>";
    my $properties = $g_sections{'properties'};
    my $propdescs = '';

    my $r_fixquotes = sub {
        no warnings;
        my $text = shift;
        my $type = shift;
        if ($type eq 'String') {
            my $quote = chr(0x22);
            return $text if ($text =~ /^\x22.*\x22/); # return if properly quoted
            return $text =~ s/\x27/$quote/rg; # replace single quotes with double quotes
        }
        return $text;
    };

    foreach my $prop (@$properties) {
        my $text = sprintf('<tr><td>%s</td><td>%s</td><td>%s</td></tr>', $prop->get('type'), $prop->get('name'), $prop->get('default'));
        append($table, $text . "\n");

        my $propdesc = _LoadTemplateOnce('property', 'c/propdesc.html');

        $propdesc =~ s/\[PROPNAME\]/$prop->get('name')/eg;
        $propdesc =~ s/\[PROPSIG\]/$prop->get('type') . ' ' . $prop->get('name')/e;

        my $deleted = 0;

        # Default value
        if ($prop->get('default') ne '') {
            my $temp = &$r_fixquotes($prop->get('default'), $prop->get('type'));
            $propdesc =~ s/\[PROPDEFAULT\]/$temp/;
        } else {
            $propdesc = delete_block_id($propdesc, $prop->get('name') . "_default");
            ++$deleted;
        }

        # Property setter function
        if ($prop->get('setter') ne '') {
            $propdesc =~ s/\[PROPSETTER\]/$prop->get('setter')/e;
        } else {
            $propdesc = delete_block_id($propdesc, $prop->get('name') . "_setter");
            ++$deleted;
        }

        # Property getter function
        if ($prop->get('getter') ne '') {
            $propdesc =~ s/\[PROPGETTER\]/$prop->get('getter')/e;
        } else {
            $propdesc = delete_block_id($propdesc, $prop->get('name') . "_getter");
            ++$deleted;
        }

        # If all table elements are deleted
        if ($deleted >= 3) {
            $propdesc = delete_block_class($propdesc, "bicolor_light");
        }

        # Property description
        {
            my $r_array = $prop->get('description');
            if (ref($r_array) eq 'ARRAY') {
                $text = '';
                foreach (@$r_array) {
                    append($text, '<p>' . $_ . '</p>');
                }
                $propdesc =~ s/\[PROPDESC\]/$text/e;
            } else {
                $propdesc =~ s/\[PROPDESC\]//;
            }

            my $brief = $prop->get('brief');
            $propdesc =~ s/\[PROPBRIEF\]/$brief/;
        }

        append($propdescs, $propdesc);
    }
    append($table, "</table>");

    $$r_html =~ s{\[PROPERTIES\]}{$table . "\n<br>\n" . $propdescs}e;
}

sub _FormatTypeNames {
    my $r_html = shift;

    my $pattern;
    {
        my $temp = join('|', POD_TYPES);
        $pattern = qr/$temp/;
    }

    $$r_html =~ s{\b($pattern)\b}{
        sprintf(q^<span class="podtype">%s</span>^, $1);
    }eg;

    {
        my $temp = join('|', COMPLEX_TYPES);
        $pattern = qr/$temp/;
    }

    $$r_html =~ s{\b($pattern)}{
        sprintf(q^<span class="complextype">%s</span>^, $1);
    }eg;
}

sub _ParseFormatTags {
    my $r_html = shift;
    my %tags = (
        code => '<code>%s</code>',
        b => '<b>%s</b>',
        i => '<i>%s</i>',
        a => '<i class="argument">%s</i>',
        function => '<code class="function">%s</code>',
        class => '<code class="class">%s</code>'
    );

    $$r_html =~ s/\@br/<br>/g;

    my $pattern;
    {
        my $temp = join('|', keys %tags);
        $pattern = qr/$temp/;
    }

    $$r_html =~ s{
        (?:
            \@($pattern)
            \s+
            (\w+)
        )
    }{
        sprintf($tags{$1}, $2);
    }egx;

    $$r_html =~ s{
        (?:
            \@($pattern)
            \{
            (\N+)
            \}
        )
    }{
        sprintf($tags{$1}, $2);
    }egx;
}

sub _DetectDocType {
    my $text = shift;
    my $index = shift;
    my $doc_text = '';
    my $doc_type = 'unknown';
    my $is_func = 0;

    # Continue until you reach a non-comment line
    my $line;
    do {
        $line = getline($text, \$index);
        if (! $is_func) {
            append($doc_text, $line . "\n");
        } else {
            if (startswith($line, "\t")) {
                $line = '';
            }
            append($doc_text, $line . "\n");
        }

        if (startswith($line, 'func')) {
            $is_func = 1;
        }
    } while ( hascontent($line) );

    # In the case of a one-line function, hide the code in the body
    # func example() -> void: pass
    #                         ^^^^
    #                         Removes this
    if ($is_func) {
        $doc_text = rtrim($doc_text);
        $doc_text =~ s/(func.*:).*$/$1/;
    }

    $doc_text = ltrim($doc_text); # Trim leading whitespace

    no warnings;
    given ($doc_text) {
        when (/^(?:export)?.*[ \t]*var\b.*/m) {
            $doc_type = 'export';
        }
        when (/^(class_name|extends).*/m) {
            $doc_type = 'class';

            if ($1 eq 'class_name') {
                if ( ! contains($doc_text, 'extends') ) {
                    $index = index($text, 'extends');
                    append($doc_text, getline($text, \$index));
                }
            } else {
                if ( ! contains($doc_text, 'class_name') ) {
                    $index = index($text, 'class_name');
                    append($doc_text, getline($text, \$index));
                }
            }
        }
        when (/^signal[ \t]+\w+/m) {
            $doc_type = 'signal';
        }
        when (/^func[ \t]+\w+[ \t]*\((.|\n)*\).*:/m) {
            $doc_type = 'method';
        }
        when (/^const[ \t]+\w+[ \t]*\=[ \t]*.+/m) {
            unless ($doc_text =~ /^#[ \t]*\@type[ \t]+\w+/m) {
                printerr("Missing required \@type tag. Unable to discern type of constant.");
                break;
            }
            $doc_type = 'constant';
        }
        when (/^enum([ \t])+\w+\1*\{(.|\n)*?\}/m) {
            $doc_type = 'enum';
        }
        default {
            printerr(qq/Unknown documentation block: "$doc_text"/);
        }
    }

    $doc_text =~ s/\n\n/\n/m;

    return { 'text' => $doc_text, 'type' => rtrim($doc_type) };
}

# Parse functions

sub ParseEntity {
    my $text = shift;
    my $key = shift;

    if (exists $g_parse_subs{$key}) {
        return &{ $g_parse_subs{$key} }($text, $key);
    }
}

sub _ParseEnum {
    use Doctool::Enum;
    my $text = shift;
    my $enum = Doctool::Enum->new();

    #$enum->set('name', scalar strextract(qr/\nenum([ \t])+(\w+)\1*/, 2) );

    $enum->set('name', $2) if ( $text =~ /^enum([ \t])+(\w+)\1*/m );

    $enum->set('brief', $1) if ( $text =~ /^##[ \t]*(.+)/ );

    # @constant {$1:name} {$2:value} {$3:brief}
    while ( $text =~ /#[ \t]*\@constant[ \t]+(\w+)[ \t]+([^\s]+)[ \t]+(\N+)/mg ) {
        #echo "$enum->add_constant($1, $2, $3)";
        $enum->add_constant($1, $2, $3);
    }

    push($g_sections{'enums'}->@*, $enum);
}

sub _ParseConstant {
    my $text = shift;
    my $constant = {
        brief => '',
        value => '',
        name => '',
        type => ''
    };

    $constant->{'type'} = $1;

    $constant->{'brief'} = strextract(qr/##[ \t]*(.*)/, $text, 1);

    my @values = strextract(qr/const[ \t]+(\w+)[ \t]*\=[ \t]*(.*)/, $text, 1, 2);
    $constant->{'name'} = $values[0];
    $constant->{'value'} = $values[1];

    push($g_sections{'constants'}->@*, $constant);
}

sub _ParseMethod {
    use Doctool::Method;
    use Doctool::Arg;
    use String::Util 'collapse';

    my $text = shift;
    my $method = Doctool::Method->new();

    # $1 = name
    # $2 = args
    # $3 = return type
    unless (
        $text =~ m{
            ^          #
            func       # Starts with the word "func" followed by spaces.
            [ \t]+     #
            (\w+)      # Function name = $1
            [ \t]*     #
            \(         #
            (.*)       # Inside paranthesis are the parameters (can be multiline)
            \)         # which, if defined, are captured in $2.
            [ \t]*     #
            (?:        # Optional return type
                \s*    #
                ->     # Needs '->'
                \s*    #
                (\w*)  # And the type name, captured in $3.
            )?
        }mxs
    ) {
        die "Malformed function: $text";
    }

    $method->set('name', $1); # Method name

    {
        # Method return type
        my $rettype = defined($3) ? collapse($3) : 'Variant';
        $method->set('returntype', $rettype);
    }

    # Argument list
    if (defined $2) {
        my @arglist = split(/\,[ \t\n]*/, $2);
        foreach my $arg (@arglist) {
            my $obj = Doctool::Arg->new();

            {
                # $1 = name
                my $match = strextract(qr/(\w+)\:?/, $arg, 1);
                die "Missing argument name: \"$arg\"" if (! $match);
                $obj->set('name', $match);

                # type
                $match = strextract(qr/\:[ \t]*(\w+)/, $arg, 1);
                $obj->set('type', ($match) ? $match : 'Variant');

                # default
                $match = strextract(qr/\=[ \t]*(.+)/, $arg, 1);
                $obj->set('default', $match);
            }

            $method->add_arg($obj);
        }
    }

    {
        # Description
        my $brief = strextract(qr/^##[ \t]*(.+)/, $text, 1);
        if ( hascontent($brief) ) {
            $method->set('brief', $brief);
        }

        my $i = index($text, '@desc');
        if ($i > 0) {
            $i += length('@desc');
            $method->set('description', _GetParagraphs($text, \$i));
        }
    }

    $method->set($1, 1) while ($text =~ /#[ \t]*\@(virtual|const)$/mg);

    push($g_sections{'methods'}->@*, $method);
}

sub _ParseSignal {
    use Doctool::Signal;
    use Doctool::Arg;

    my $text = shift;
    my $signal = Doctool::Signal->new();

    # Name of the signal
    $signal->set('name', strextract(qr/signal[ \t]+(\w+)/, $text, 1));

    # Signal parameters
    while ( $text =~ /^#[ \t]*\@arg[ \t]*(\w+)[ \t]+(\w+)[ \t]+(.+)/gm ) {
        my $arg = Doctool::Arg->new();
        $arg->set('type', $1);
        $arg->set('name', $2);
        $arg->set('description', $3);
        $signal->add_arg($arg);
    }

    # Brief description
    $signal->set('brief',  strextract($g_brief_regex, $text, 1));

    # Full description
    my $i = index($text, '@desc');
    if ($i > 0) {
        $i += length('@desc');
        $signal->set('description', _GetParagraphs($text, \$i));
    }

    push($g_sections{'signals'}->@*, $signal);
}

sub _ParseClass {
    my $text = shift;
    my %header;
    my $index = 0;

    # Look for the name of the class
    $header{'class'} = strextract(qr/class_name\s+(\w+)/, $text, 1);

    # Get the brief description first.
    $header{'brief'} = strextract($g_brief_regex, $text, 1);

    $index = index($text, '@desc');
    if ($index > 0) {
        $index += length('@desc');
        $header{'description'} = _GetParagraphs($text, \$index);
    }

    die q/Syntax error: no "extends" found in input/ unless ($text =~ /^extends[ \t]+(\w+)/m);
    $header{'extends'} = $1;

    $g_sections{'header'} = \%header;
}

sub _ParseProperty {
    use Doctool::Property;
    my $text = shift;
    my $prop = Doctool::Property->new();

    # Get the brief description first.
    if ($text =~ /$g_brief_regex/) {
        $prop->set('brief', $1);
    }

    # Name
    die "REGEX failed" unless ($text =~ /^(?:export.*)?[ \t]*var[ \t]+(\w+)/m);
    $prop->set('name', $1);

    # Property type
    # TODO: thrown an exception if the type is not one of Godot's recognized types
    die str("Property ", $prop->get('name'), " needs a type") unless ($text =~ /^#[ \t]*\@type[ \t]+(\w+)/m);
    $prop->set('type', $1);

    # Default
    if ($text =~ /\=[ \t]*(\N+)/) {
        $prop->set('default', $1);
    }

    # Getter/setter function
    while ($text =~ /\@([sg]etter)[ \t]+(\w+\(.*\))/g) {
        my $tag = $1;
        if ($tag eq 'setter') {
            $prop->set('setter', $2);
        } else {
            $prop->set('getter', $2);
        }
    }

    {
        # Full description
        my $index = index($text, '@desc');
        if ($index > 0) {
            $index += length('@desc');
            $prop->set('description', _GetParagraphs($text, \$index));
        }
    }

    push($g_sections{'properties'}->@*, $prop);
}


# Usage: _GetParagraphs $text \$index
# Returns a reference to an array of paragraph strings
# Entry condition: $index is set to the index right after the tag name in $text
sub _GetParagraphs {
    my $text = shift;
    my $r_index = shift; # reference

    my $index = $$r_index;
    my $graff = getline($text, \$index);

    my $line;
    my @pars = ();

    do {
        $line = getline($text, \$index);

        # Look for text on each line
        if ($line =~ /^#\s*(.+)/) {
            my $add_to_graff = $1;

            # New paragraph, and the first thing we see is a section tag
            # FIXME: this might present an issue for the cases where $g_sec_tags is found directly one line below a paragraph (no empty line above it)
            if ($graff eq '' && $line =~ /^#\s*\@desc/) {
                $line = '';
                prevline($text, $index);
            } else {
                $graff = $graff . " $add_to_graff";
            }
        } else {
            # Ending the paragraph and appending it to the array
            if ($graff ne '') {
                $graff =~ s{\@desc}{}g; # Remove stray section tags
                $graff = ltrim($graff);
                $graff =~ s{\s\s+}{ }g; # Turn duplicate spaces into just one
                push(@pars, $graff);
                $graff = '';
            }
        }
    } while (index($line, '#') == 0);

    $$r_index = $index;

    return \@pars;
}

1;
