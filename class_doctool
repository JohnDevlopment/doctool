#!/usr/bin/perl

use strict;
use warnings;
use v5.10;

# Doctool Modules
use FindBin;
use lib "$FindBin::Bin/lib";

use Doctool::Getline;
use Doctool::Property;
use Doctool::Util qw(append echo str);
use String::Util qw(ltrim rtrim hascontent contains);

use Digest::MD5 qw(md5_hex);

my %g_sec_tag_keys = qw(desc description note note);
my %g_sections;
my $g_sec_tags = qr/desc|note/;

use constant POD_TYPES => qw(
    float int void Variant String Dictionary Array
    PoolRealArray PoolIntArray PoolStringArray
    PoolVector2Array PoolVector3Array PoolColorArray
);

use constant COMPLEX_TYPES => qw(
    Vector2
    Vector3
    Rect2
    Transform2D
    Transform
    Plane
    Quat
    AABB
    Basis
    Color
    NodePath
    RID
    Object
);

# Usage: _delete_block_attr text attr value
sub _delete_block_attr ($$$) {
    my ($text,$attr,$value) = @_;
    my $block = qr/section|article|div|table|header/;
    $text =~ s{
        (
            ^              # Spaces from the start
            [ \t]*         # leading to the block
            <($block)      # $2 = block
            \s+            # One or more spaces
            $attr="$value" # Specific attribute
            (?:.|\n)*?     # Any number lines
            </\2>          # Matching end tag
            [ \t]*         # Trailing spaces
            \n?            # Newline
        )
    }{
        my $key = md5_hex($1);
        "<!-- " . $key . " -->\n";
    }emx;

    return $text;
}

# Usage: delete_block string, class
sub delete_block_class ($$) {return _delete_block_attr($_[0], 'class', $_[1]);}

# Usage: delete_block string, id
sub delete_block_id ($$) {return _delete_block_attr($_[0], 'id', $_[1]);}

# Main subroutine
sub Doctool {
    my $text = shift or die "Needs a string argument";

    my %parse_subs = (
        export => \&_ParseProperty,
        class => \&_ParseClass
    );

    # Clear global hash
    %g_sections = ();

    # Standardize line endings:
    $text =~ s{\r\n}{\n}g; 	# DOS to Unix
    $text =~ s{\r}{\n}g; 	# Mac to Unix

    # Require that the very first line be a comment with two "#" and text
    die 'No documentation found for this class' unless ($text =~ /^##\s*.+/);

    while ($text =~ /^(?=##\s*)/gm) {
        my $index = pos($text);
        my $doc = _DetectDocType($text, $index);

        my $key = $doc->{'type'};
        if (exists $parse_subs{$key}) {
            &{$parse_subs{$key}}($doc->{'text'});
        }
    }

    return _BuildHTML();
}

sub _BuildHTML {
    # Read template.html into a buffer
    my $html = '';
    open(HANDLE, '<', './template.html') or die $!;
    while (<HANDLE>) {
        $html = $html . $_;
    }
    close(HANDLE);

    # Parse header section
    my %header = %{ $g_sections{'header'} };

    {
        my $extends = sprintf('<p>Inherits from: %s</p>', $header{'extends'});
        $html =~ s{
            \n
            ([ \t]*)
            (?=.*\[BRIEF\])
        }{
            "\n$1" . $extends . "\n$1";
        }ex;
    }

    $html =~ s/\[CLASSNAME\]/$header{'class'}/g;
    $html =~ s/\[BRIEF\]/$header{'brief'}/;

    {
        # Description
        my $text = '';
        for my $i (0 .. $header{'description'}->$#*) {
            $text = $text . '<p>' . $header{'description'}[$i] . '</p>';
        }

        if (exists $header{'note'}) {
            my $buf = '';
            for my $i (0 .. $header{'note'}->$#*) {
                $buf = $buf . '<p>' . $header{'note'}[$i] . '</p>';
            }
            $text = $text . sprintf(q^<div class="note">%s</div>^, $buf);
        }
        $html =~ s/\[DESC\]/$text/;
    }

    # Properties section
    #if (! exists $g_sections{'properties'}) {
    #    $html = delete_block_id($html, 'properties');
    #} else {
    #    my $table = "<table><tr><th>Type</th><th>Name</th><th>Default</th></tr>";
    #    my $properties = $g_sections{'properties'};
    #
    #    for my $prop (@$properties) {
    #        my $tr = sprintf('<tr><td>%s</td><td>%s</td><td>%s</td></tr>', $prop->type, $prop->name, $prop->default);
    #        append($table, $tr . "\n");
    #    }
    #
    #    append($table, "</table>");
    #
    #    $html =~ s{\[PROPERTIES\]}{$table};
    #}

    # Methods section
    #if (! exists $g_sections{'methods'}) {
    #    $html = delete_block_id($html, 'methods');
    #}

    # Signals section
    #if (! exists $g_sections{'signals'}) {
    #    $html = delete_block_id($html, 'signals');
    #}

    #$html = _ParseFormatTags($html);
    #$html = _FormatTypeNames($html);

    return $html;
}

sub _FormatTypeNames {
    my $html = shift;

    my $pattern;
    {
        my $temp = join('|', POD_TYPES);
        $pattern = qr/$temp/;
    }

    $html =~ s{\b($pattern)}{
        sprintf(q^<span class="podtype">%s</span>^, $1);
    }eg;

    {
        my $temp = join('|', COMPLEX_TYPES);
        $pattern = qr/$temp/;
    }

    $html =~ s{\b($pattern)}{
        sprintf(q^<span class="complextype">%s</span>^, $1);
    }eg;

    return $html;
}

sub _ParseFormatTags {
    my $html = shift;
    my %tags = (
        code => '<code>%s</code>',
        b => '<b>%s</b>',
        i => '<i>%s</i>'
    );

    $html =~ s/\@br/<br>/g;

    foreach my $key (keys %tags) {
        $html =~ s{
            (?:
                \@$key
                \s*
                (\w+)
            )
        }{
            sprintf($tags{$key}, $1);
        }egx;
    }

    return $html;
}

# Returns what type of documentation we're dealing with, also isolates the chunk for us
# Params
#    text to sift through
#    index to start the search from
# Return value
#    A reference to a hash with two fields
#      * $hash{'text'} = a string with the documentation and the entity being documented
#      * $hash{'type'} = string denoting the type of documentation
sub _DetectDocType {
    my $text = shift;
    my $index = shift;
    my $doc_text = '';
    my $doc_type = 'unknown';
    my $is_func = 0;

    # Continue until you reach a non-comment line
    my $line;
    do {
        use String::Util 'startswith';
        $line = getline($text, $index);
        if (! $is_func) {
            append($doc_text, $line . "\n");
        }

        if ( startswith($line, 'func') ) {
            $is_func = 1;
        }
    } while ( hascontent($line) );

    if ($is_func) {
        $doc_text =~ s/^(func.*:).*/$1/m;
    }

    $doc_text = ltrim($doc_text);

    no warnings;
    given ($doc_text) {
        when (/^(?:export)?.*[ \t]*var\b.*/m) {
            $doc_type = 'export';
        }
        when (/^(class_name|extends).*/m) {
            $doc_type = 'class';

            if ($1 eq 'class_name') {
                if ( ! contains($doc_text, 'extends') ) {
                    $index = index($text, 'extends');
                    append($doc_text, getline($text, $index));
                }
            } else {
                if ( ! contains($doc_text, 'class_name') ) {
                    $index = index($text, 'class_name');
                    append($doc_text, getline($text, $index));
                }
            }
        }
        when (/^(signal|enum|func)\b.*/m) {
            $doc_type = $1;
        }
        default {1;}
    }

    $doc_text =~ s/\n\n/\n/m;

    return { 'text' => $doc_text, 'type' => rtrim($doc_type) };
}

# Usage: _GetParagraphs $text \$index
# Returns an array of paragraph strings
# Entry condition: $index is set to the index right after the tag name in $text
sub _GetParagraphs {
    my $text = shift;
    my $r_index = shift; # reference

    my $index = $$r_index;
    my $graff = getline($text, $index);

    my $line;
    my @pars = ();

    do {
        $line = getline($text, $index);

        # Look for text on each line
        if ($line =~ /^#\s*(.+)/) {
            my $add_to_graff = $1;

            # New paragraph, and the first thing we see is a section tag
            if ($graff eq '' && $line =~ /^#\s*\@$g_sec_tags/) {
                $line = '';
                prevline($text, $index);
            } else {
                $graff = $graff . " $add_to_graff";
            }
        } else {
            # Ending the paragraph and appending it to the array
            if ($graff ne '') {
                $graff =~ s{\@$g_sec_tags}{}g; # Remove stray section tags
                $graff = ltrim($graff);
                $graff =~ s{\s\s+}{ }g; # Turn duplicate spaces into just one
                append(@pars, $graff);
                $graff = '';
            }
        }
    } while (index($line, '#') == 0);

    $$r_index = $index;

    return \@pars;
}

# _ParseClass string
# Fields: brief (string), class (string), desc (string, optional), extends
sub _ParseClass {
    my $text = shift;
    my %header;
    my $line;
    my $index = 0;

    # Look for the name of the class
    $text =~ /class_name\s+(\w+)/;
    $header{'class'} = $1;

    # Get the brief description first.
    $line = getline($text, $index);
    $header{'brief'} = ($text =~ /^##\s*(.+)/) ? $1 : 'No description available';

    # Look for tags in the comments
    do {
        $line = getline($text, $index);

        # If a section-tag is found:
        if ($line =~ /^#\s*\@($g_sec_tags)/) {
            my $tag = $1; # e.g., 'desc'
            my $key = $g_sec_tag_keys{$tag}; # e.g., 'description'

            # Move index in front of tag
            # To explain the math here:
            # $index is currently the index to the NEXT line, so we subtract the length
            # of THIS line, and subtract one, to bring it back to the start of the current line.
            # Then we add the index of the tag (e.g., "@desc") to it, then add its length,
            # to bring the index in front of the tag.
            # The result should be that $index is at the index after  the tag.
            my $i = index($line, '@' . $1);
            $index = ($index - length($line) - 1) + $i + length('@' . $1);

            $header{$key} = _GetParagraphs($text, \$index);
        }
    } while (index($line, '#') == 0);

    die q/Syntax error: no "extends" found in input/ unless ($text =~ /^extends[ \t]+(\w+)/m);
    $header{'extends'} = $1;

    $g_sections{'header'} = \%header;
}

sub _ParseFunction {}

# _ParseProperty string
# Note: $g_section{'properties'} is a list of Doctool::Property objects.
#       The attributes are: brief, name, default, type, description (ARRAY)
sub _ParseProperty {
    my $text = shift;
    my $prop = Doctool::Property->new();
    my $index = 0;
    my $line = '';

    # Get the brief description first.
    $line = getline($text, $index);
    $prop->brief( ($text =~ /^##\s*(.+)/) ? $1 : 'No description available' );

    do {
        $line = getline($text, $index);

        # Found a section tag
        if ($line =~ /^#\s*\@($g_sec_tags)/) {
            my $tag = $1; # e.g., 'desc'
            my $key = $g_sec_tag_keys{$tag}; # e.g., 'description'

            # Move index in front of tag
            # To explain the math here:
            # $index is currently the index to the NEXT line, so we subtract the length
            # of THIS line, and subtract one, to bring it back to the start of the current line.
            # Then we add the index of the tag (e.g., "@desc") to it, then add its length,
            # to bring the index in front of the tag.
            # The result should be that $index is at the index after  the tag.
            my $i = index($line, '@' . $1);
            $index = ($index - length($line) - 1) + $i + length('@' . $1);

            $prop->description(_GetParagraphs($text, \$index));
        }
    } while (index($line, '#') == 0);

    if (! exists $g_sections{'properties'}) {
        $g_sections{'properties'} = ();
    }

    Doctool::Util::push_back(@{$g_sections{'properties'}}, $prop);
}

# Read file given by argument
if (defined($ARGV[0])) {
    my $text;
    local $/;
    defined($text = <>) or exit 1;
    print Doctool($text);
}

1;
