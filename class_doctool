#!/usr/bin/perl

use strict;
use warnings;
use v5.10;

# Doctool Modules
use FindBin;
use lib "$FindBin::Bin/lib";

use Doctool::Getline;
use Doctool::Property;
use Doctool::Util qw(append echo str push_back);
use String::Util qw(ltrim rtrim hascontent contains);
use Readonly;

use Digest::MD5 qw(md5_hex);

my %g_sec_tag_keys = qw(desc description note note);
my %g_sections;
Readonly::Scalar my $g_sec_tags => qr/desc|note/;

use constant POD_TYPES => qw(
    float int void Variant String Dictionary Array
    PoolRealArray PoolIntArray PoolStringArray
    PoolVector2Array PoolVector3Array PoolColorArray
);

use constant COMPLEX_TYPES => qw(
    Vector2
    Vector3
    Rect2
    Transform2D
    Transform
    Plane
    Quat
    AABB
    Basis
    Color
    NodePath
    RID
    Object
);

# TODO: #1 uncomment this after finishing todo #2
#use constant PROP_DESC_TEMPLATE => <<EOF;
#afl;sadjfkjasldfkjhsakjdhgfkjsdlhgkj
#asfafsdafsdfds
#EOF

# Usage: _delete_block_attr text attr value
sub _delete_block_attr ($$$) {
    my ($text,$attr,$value) = @_;
    my $block = qr/section|article|div|table|header|tr|td|tbody/;
    $text =~ s{
        (
            ^              # Spaces from the start
            [ \t]*         # leading to the block
            <($block)      # $2 = block
            \s+            # One or more spaces
            $attr="$value" # Specific attribute
            (?:.|\n)*?     # Any number lines
            </\2>          # Matching end tag
            [ \t]*         # Trailing spaces
            \n?            # Newline
        )
    }{
        my $key = md5_hex($1);
        "<!-- " . $key . " -->\n";
    }emx;

    return $text;
}

# Usage: delete_block string, class
sub delete_block_class ($$) {return _delete_block_attr($_[0], 'class', $_[1]);}

# Usage: delete_block string, id
sub delete_block_id ($$) {return _delete_block_attr($_[0], 'id', $_[1]);}

# Main subroutine
sub Doctool {
    my $text = shift or die "Needs a string argument";

    my %parse_subs = (
        export => \&_ParseProperty,
        class => \&_ParseClass
    );

    # Clear global hash
    %g_sections = ();

    # Standardize line endings:
    $text =~ s{\r\n}{\n}g; 	# DOS to Unix
    $text =~ s{\r}{\n}g; 	# Mac to Unix

    # Require that the very first line be a comment with two "#" and text
    die 'No documentation found for this class' unless ($text =~ /^##\s*.+/);

    while ($text =~ /^(?=##\s*)/gm) {
        my $index = pos($text);
        my $doc = _DetectDocType($text, $index);

        my $key = $doc->{'type'};
        if (exists $parse_subs{$key}) {
            &{$parse_subs{$key}}($doc->{'text'});
        }
    }

    return _BuildHTML();
}

sub _BuildHTML {
    my $html = Doctool::Util::readfile("$FindBin::Bin/template.html");

    # Parse header section
    my %header = %{ $g_sections{'header'} };

    {
        my $extends = sprintf('<p>Inherits from: %s</p>', $header{'extends'});
        $html =~ s{
            \n
            ([ \t]*)
            (?=.*\[BRIEF\])
        }{
            "\n$1" . $extends . "\n$1";
        }ex;
    }

    $html =~ s/\[CLASSNAME\]/$header{'class'}/g;
    $html =~ s/\[BRIEF\]/$header{'brief'}/;

    {
        # Description
        my $text = '';
        for my $i (0 .. $header{'description'}->$#*) {
            $text = $text . '<p>' . $header{'description'}[$i] . '</p>';
        }

        if (exists $header{'note'}) {
            my $buf = '';
            for my $i (0 .. $header{'note'}->$#*) {
                $buf = $buf . '<p>' . $header{'note'}[$i] . '</p>';
            }
            $text = $text . sprintf(q^<div class="note">%s</div>^, $buf);
        }
        $html =~ s/\[DESC\]/$text/;
    }

    # Properties section
    if (! exists $g_sections{'properties'}) {
        $html = delete_block_id($html, 'properties');
    } else {
        my $table = "<table class=\"bicolor\"><tr><th>Type</th><th>Name</th><th>Default</th></tr>";
        my $properties = $g_sections{'properties'};
        my $propdescs = '';

        Readonly my $c_propdesc_html => Doctool::Util::readfile("$FindBin::Bin/c/propdesc.html");

        my $r_fixquotes = sub {
            no warnings;
            my $text = shift;
            my $type = shift;
            if ($type eq 'String') {
                my $quote = chr(0x22);
                return $text if ($text =~ /^\x22.*\x22/); # return if properly quoted
                return $text =~ s/\x27/$quote/rg; # replace single quotes with double quotes
            }
            return $text;
        };

        foreach my $prop (@$properties) {
            my $text = sprintf('<tr><td>%s</td><td>%s</td><td>%s</td></tr>', $prop->type(), $prop->name(), $prop->default());
            append($table, $text . "\n");

            my $propdesc = $c_propdesc_html;
            my $propname = $prop->name();

            $propdesc =~ s/\[PROPNAME\]/$propname/g;
            {
                my $temp = &$r_fixquotes($prop->default(), $prop->type());
                $propdesc =~ s/\[PROPDEFAULT\]/$temp/;
            }
            $propdesc =~ s/\[PROPSIG\]/$prop->type() . ' ' . $propname/e;

            # Property setter function
            if ($prop->setter() ne '') {
                $propdesc =~ s/\[PROPSETTER\]/$prop->setter()/e;
            } else {
                $propdesc = delete_block_id($propdesc, "${propname}_setter");
            }

            # Property getter function
            if ($prop->getter() ne '') {
                $propdesc =~ s/\[PROPGETTER\]/$prop->getter()/e;
            } else {
                $propdesc = delete_block_id($propdesc, "${propname}_getter");
            }

            # Property description
            {
                my $r_array = $prop->description();
                if (ref($r_array) eq 'ARRAY') {
                    $text = '';
                    foreach (@$r_array) {
                        append($text, '<p>' . $_ . '</p>');
                    }
                    $propdesc =~ s/\[PROPDESC\]/$text/e;
                } else {
                    $propdesc =~ s/\[PROPDESC\]//;
                }
            }

            append($propdescs, $propdesc);
        }
        append($table, "</table>");

        $html =~ s{\[PROPERTIES\]}{$table . "\n<br>\n" . $propdescs}e;
    }

    # Methods section
    if (! exists $g_sections{'methods'}) {
        $html = delete_block_id($html, 'methods');
    }

    # Signals section
    if (! exists $g_sections{'signals'}) {
        $html = delete_block_id($html, 'signals');
    }

    $html = _ParseFormatTags($html);
    $html = _FormatTypeNames($html);

    $html =~ s/<!--.*?-->//g;
    $html =~ s/\n{2,}/\n/g;

    return $html;
}

sub _FormatTypeNames {
    my $html = shift;

    my $pattern;
    {
        my $temp = join('|', POD_TYPES);
        $pattern = qr/$temp/;
    }

    $html =~ s{\b($pattern)\b}{
        sprintf(q^<span class="podtype">%s</span>^, $1);
    }eg;

    {
        my $temp = join('|', COMPLEX_TYPES);
        $pattern = qr/$temp/;
    }

    $html =~ s{\b($pattern)}{
        sprintf(q^<span class="complextype">%s</span>^, $1);
    }eg;

    return $html;
}

sub _ParseFormatTags {
    my $html = shift;
    my %tags = (
        code => '<code>%s</code>',
        b => '<b>%s</b>',
        i => '<i>%s</i>',
        function => '<code class="function">%s</code>',
        class => '<code class="class">%s</code>'
    );

    $html =~ s/\@br/<br>/g;

    my $pattern;
    {
        my $temp = join('|', keys %tags);
        $pattern = qr/$temp/;
    }

    $html =~ s{
        (?:
            \@($pattern)
            \s+
            (\w+)
        )
    }{
        sprintf($tags{$1}, $2);
    }egx;

    $html =~ s{
        (?:
            \@($pattern)
            \{
            (\N+)
            \}
        )
    }{
        sprintf($tags{$1}, $2);
    }egx;

    return $html;
}

# Returns what type of documentation we're dealing with, also isolates the chunk for us
# Params
#    text to sift through
#    index to start the search from
# Return value
#    A reference to a hash with two fields
#      * $hash{'text'} = a string with the documentation and the entity being documented
#      * $hash{'type'} = string denoting the type of documentation
sub _DetectDocType {
    my $text = shift;
    my $index = shift;
    my $doc_text = '';
    my $doc_type = 'unknown';
    my $is_func = 0;

    # Continue until you reach a non-comment line
    my $line;
    do {
        use String::Util 'startswith';
        $line = getline($text, $index);
        if (! $is_func) {
            append($doc_text, $line . "\n");
        }

        if ( startswith($line, 'func') ) {
            $is_func = 1;
        }
    } while ( hascontent($line) );

    if ($is_func) {
        $doc_text =~ s/^(func.*:).*/$1/m;
    }

    $doc_text = ltrim($doc_text);

    no warnings;
    given ($doc_text) {
        when (/^(?:export)?.*[ \t]*var\b.*/m) {
            $doc_type = 'export';
        }
        when (/^(class_name|extends).*/m) {
            $doc_type = 'class';

            if ($1 eq 'class_name') {
                if ( ! contains($doc_text, 'extends') ) {
                    $index = index($text, 'extends');
                    append($doc_text, getline($text, $index));
                }
            } else {
                if ( ! contains($doc_text, 'class_name') ) {
                    $index = index($text, 'class_name');
                    append($doc_text, getline($text, $index));
                }
            }
        }
        when (/^(signal|enum|func)\b.*/m) {
            $doc_type = $1;
        }
        default {1;}
    }

    $doc_text =~ s/\n\n/\n/m;

    return { 'text' => $doc_text, 'type' => rtrim($doc_type) };
}

# Usage: _GetParagraphs $text \$index
# Returns a reference to an array of paragraph strings
# Entry condition: $index is set to the index right after the tag name in $text
sub _GetParagraphs {
    my $text = shift;
    my $r_index = shift; # reference

    my $index = $$r_index;
    my $graff = getline($text, $index);

    my $line;
    my @pars = ();

    do {
        $line = getline($text, $index);

        # Look for text on each line
        if ($line =~ /^#\s*(.+)/) {
            my $add_to_graff = $1;

            # New paragraph, and the first thing we see is a section tag
            if ($graff eq '' && $line =~ /^#\s*\@$g_sec_tags/) {
                $line = '';
                prevline($text, $index);
            } else {
                $graff = $graff . " $add_to_graff";
            }
        } else {
            # Ending the paragraph and appending it to the array
            if ($graff ne '') {
                $graff =~ s{\@$g_sec_tags}{}g; # Remove stray section tags
                $graff = ltrim($graff);
                $graff =~ s{\s\s+}{ }g; # Turn duplicate spaces into just one
                push_back(@pars, $graff);
                $graff = '';
            }
        }
    } while (index($line, '#') == 0);

    $$r_index = $index;

    return \@pars;
}

# _ParseClass string
# Fields: brief (string), class (string), desc (string, optional), extends
sub _ParseClass {
    my $text = shift;
    my %header;
    my $line;
    my $index = 0;

    # Look for the name of the class
    $text =~ /class_name\s+(\w+)/;
    $header{'class'} = $1;

    # Get the brief description first.
    $line = getline($text, $index);
    $header{'brief'} = ($text =~ /^##\s*(.+)/) ? $1 : 'No description available';

    # Look for tags in the comments
    do {
        $line = getline($text, $index);

        # If a section-tag is found:
        if ($line =~ /^#\s*\@($g_sec_tags)/) {
            my $tag = $1; # e.g., 'desc'
            my $key = $g_sec_tag_keys{$tag}; # e.g., 'description'

            # Move index in front of tag
            # To explain the math here:
            # $index is currently the index to the NEXT line, so we subtract the length
            # of THIS line, and subtract one, to bring it back to the start of the current line.
            # Then we add the index of the tag (e.g., "@desc") to it, then add its length,
            # to bring the index in front of the tag.
            # The result should be that $index is at the index after  the tag.
            my $i = index($line, '@' . $1);
            $index = ($index - length($line) - 1) + $i + length('@' . $1);

            $header{$key} = _GetParagraphs($text, \$index);
        }
    } while (index($line, '#') == 0);

    die q/Syntax error: no "extends" found in input/ unless ($text =~ /^extends[ \t]+(\w+)/m);
    $header{'extends'} = $1;

    $g_sections{'header'} = \%header;
}

# _ParseProperty string
# Note: $g_section{'properties'} is a list of Doctool::Property objects.
#       The attributes are: brief, name, default, type, description (ARRAY)
sub _ParseProperty {
    my $text = shift;
    my $prop = Doctool::Property->new();
    my $index = 0;
    my $line = '';

    # Get the brief description first.
    $line = getline($text, $index);
    $prop->brief( ($text =~ /^##\s*(.+)/) ? $1 : 'No description available' );

    # Name
    die "REGEX failed" unless ($text =~ /^var[ \t]+(\w+)/m);
    $prop->name($1);

    # Property type
    die str("Property ", $prop->name(), " needs a type") unless ($text =~ /^#\s*\@type\s+(\w+)/m);
    $prop->type($1);

    # Default
    if ($text =~ /\=\s*(\N+)/) {
        $prop->default($1);
    }

    # Getter/setter function
    while ($text =~ /\@([sg]etter)[ \t]+(\w+\(.*\))/g) {
        my $tag = $1;
        if ($tag eq 'setter') {
            $prop->setter($2);
        } else {
            $prop->getter($2);
        }
    }

    do {
        $line = getline($text, $index);

        # Found a section tag
        if ($line =~ /^#\s*\@($g_sec_tags)/) {
            my $tag = $1; # e.g., 'desc'
            my $key = $g_sec_tag_keys{$tag}; # e.g., 'description'

            # Move index in front of tag
            # To explain the math here:
            # $index is currently the index to the NEXT line, so we subtract the length
            # of THIS line, and subtract one, to bring it back to the start of the current line.
            # Then we add the index of the tag (e.g., "@desc") to it, then add its length,
            # to bring the index in front of the tag.
            # The result should be that $index is at the index after  the tag.
            my $i = index($line, '@' . $1);
            $index = ($index - length($line) - 1) + $i + length('@' . $1);

            $prop->description(_GetParagraphs($text, \$index));
        }
    } while (index($line, '#') == 0);

    if (! exists $g_sections{'properties'}) {
        $g_sections{'properties'} = ();
    }

    push_back($g_sections{'properties'}->@*, $prop);
}

# Read file given by argument
if (defined($ARGV[0])) {
    my $text;
    local $/;
    defined($text = <>) or exit 1;
    print Doctool($text);
}

1;
